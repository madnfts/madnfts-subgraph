# ERC721

type ERC721Contract @entity {
  id: Bytes!
  type: String! # 0=Minimal; 1=Basic; 2=Whitelist; 3=Lazy;
  name: String!
  symbol: String!
  baseUri: String!
  maxSupply: BigInt
  royalties: BigInt
  mintPrice: BigInt
  floorPrice: BigInt
  volume: Int
  volumePrice: BigDecimal
  paused: Boolean!
  publicMintState: Boolean!
  timestamp: BigInt
  owner: Account
  splitter: Splitter!
  royaltyRecipient: Account
  tokens: [ERC721Token!]! @derivedFrom(field: "contract")
  operators: [ERC721Operator!]! @derivedFrom(field: "contract")
  transfers: [ERC721Transfer!]! @derivedFrom(field: "contract")
}

type ERC721Token @entity {
  id: ID!
  tokenId: BigInt
  uri: String!
  name: String
  symbol: String
  description: String
  image: String
  category: Int
  unlockableUrl: String
  externalUrl: String
  explicitContent: Boolean
  royalties: BigInt
  lastPrice: BigInt
  volume: Int
  volumePrice: BigDecimal
  timestamp: BigInt
  tags: [Tag!]
  attributes: [Attribute!]
  files: [File!]
  approved: Account
  owner: Account!
  contract: ERC721Contract!
  order: Order
  orders: [Order!] @derivedFrom(field: "ERC721token")
  transfers: [ERC721Transfer!] @derivedFrom(field: "token")
}

type ERC721Operator @entity {
  id: ID!
  contract: ERC721Contract!
  owner: Account!
  operator: Account!
  approved: Boolean!
}

type ERC721Transfer @entity(immutable: true) {
  id: ID!
  emitter: Account!
  from: Account!
  to: Account!
  contract: ERC721Contract!
  token: ERC721Token!
  timestamp: BigInt!
}

# ERC1155

type ERC1155Contract @entity {
  id: Bytes!
  type: String! # 0=Minimal; 1=Basic; 2=Whitelist; 3=Lazy;
  name: String!
  symbol: String!
  baseUri: String!
  maxSupply: BigInt
  royalties: BigInt
  mintPrice: BigInt
  floorPrice: BigInt
  volume: Int
  volumePrice: BigDecimal
  paused: Boolean!
  publicMintState: Boolean!
  timestamp: BigInt
  owner: Account
  splitter: Splitter!
  royaltyRecipient: Account
  tokens: [ERC1155Token!]! @derivedFrom(field: "contract")
  balances: [ERC1155Balance!]! @derivedFrom(field: "contract")
  operators: [ERC1155Operator!]! @derivedFrom(field: "contract")
  transfers: [ERC1155Transfer!]! @derivedFrom(field: "contract")
}

type ERC1155Token @entity {
  id: ID!
  tokenId: BigInt
  uri: String!
  name: String
  symbol: String
  description: String
  image: String
  category: Int
  unlockableUrl: String
  externalUrl: String
  explicitContent: Boolean
  royalties: BigInt
  lastPrice: BigInt
  volume: Int
  volumePrice: BigDecimal
  timestamp: BigInt
  tags: [Tag!]
  attributes: [Attribute!]
  files: [File!]
  totalSupply: ERC1155Balance
  contract: ERC1155Contract!
  order: Order
  orders: [Order!] @derivedFrom(field: "ERC1155token")
  balances: [ERC1155Balance!]! @derivedFrom(field: "token")
  transfers: [ERC1155Transfer!]! @derivedFrom(field: "token")
}

type ERC1155Balance @entity {
  id: ID!
  contract: ERC1155Contract!
  token: ERC1155Token!
  account: Account
  value: BigDecimal!
  valueExact: BigInt!
  timestamp: BigInt
  transferFromEvent: [ERC1155Transfer!]! @derivedFrom(field: "fromBalance")
  transferToEvent: [ERC1155Transfer!]! @derivedFrom(field: "toBalance")
}

type ERC1155Operator @entity {
  id: ID!
  contract: ERC1155Contract!
  owner: Account!
  operator: Account!
  approved: Boolean!
}

type ERC1155Transfer @entity(immutable: true) {
  id: ID!
  emitter: Account!
  timestamp: BigInt!
  contract: ERC1155Contract!
  token: ERC1155Token!
  operator: Account!
  from: Account
  fromBalance: ERC1155Balance
  to: Account
  toBalance: ERC1155Balance
  value: BigDecimal!
  valueExact: BigInt!
}

# Marketplace

type Order @entity {
  id: ID!
  type: Int! # 0=Fixed Price; 1=Dutch Auction; 2=English Auction;
  hash: Bytes!
  quantity: Int
  endPrice: BigInt
  endTime: BigInt
  startPrice: BigInt
  startTime: BigInt
  canceled: Boolean
  seller: Account!
  taker: Account
  sale: Sale
  bids: [Bid!] @derivedFrom(field: "order")
  ERC721token: ERC721Token
  ERC1155token: ERC1155Token
  ERC721contract: ERC721Contract
  ERC1155contract: ERC1155Contract
}

type Bid @entity(immutable: true) {
  id: ID!
  price: BigInt!
  timestamp: BigInt!
  owner: Account!
  order: Order!
  transaction: Transaction!
}

type Sale @entity(immutable: true) {
  id: ID!
  order: Order!
  price: BigInt!
}

type Transaction @entity(immutable: true) {
  id: ID!
  timestamp: BigInt
  events: [Event!]! @derivedFrom(field: "transaction")
  # add gas?
}

# Common

type Account @entity {
  id: Bytes!
  asERC721: ERC721Contract
  ERC721tokens: [ERC721Token!]! @derivedFrom(field: "owner")
  ERC721operatorOwner: [ERC721Operator!]! @derivedFrom(field: "owner")
  ERC721operatorOperator: [ERC721Operator!]! @derivedFrom(field: "operator")
  ERC721transferFromEvent: [ERC721Transfer!]! @derivedFrom(field: "from")
  ERC721transferToEvent: [ERC721Transfer!]! @derivedFrom(field: "to")
  asERC1155: ERC1155Contract
  ERC1155balances: [ERC1155Balance!]! @derivedFrom(field: "account")
  ERC1155operatorOwner: [ERC1155Operator!]! @derivedFrom(field: "owner")
  ERC1155operatorOperator: [ERC1155Operator!]! @derivedFrom(field: "operator")
  ERC1155transferFromEvent: [ERC1155Transfer!]! @derivedFrom(field: "from")
  ERC1155transferToEvent: [ERC1155Transfer!]! @derivedFrom(field: "to")
  ERC1155transferOperatorEvent: [ERC1155Transfer!]! @derivedFrom(field: "operator")
  events: [Event!]! @derivedFrom(field: "emitter")
}

type Splitter @entity {
  id: Bytes!
  owner: Account!
  payees: [String!]!
  percents: [BigInt!]!
  flag: BigInt
  ERC721Contracts: [ERC721Contract!]! @derivedFrom(field: "splitter")
  ERC1155Contracts: [ERC1155Contract!]! @derivedFrom(field: "splitter")
}

type Attribute @entity {
  id: ID!
  displayType: String
  traitType: String
  value: String
  maxValue: String
}

type File @entity {
  id: ID!
  displayType: String
  traitType: String
  value: String
}

type Tag @entity {
  id: ID!
  value: String
}

# Schemas & shared

type _Schema_ @fulltext(
  name: "ERC721TokenSearch"
  language: en
  algorithm: rank
  include: [
    { entity: "ERC721Token", fields: [{ name: "name" }, { name: "description" }] },
    { entity: "ERC1155Token", fields: [{ name: "name" }, { name: "description" }] }
  ]
)

interface Event {
  id: ID!
  transaction: Transaction!
  emitter: Account!
  timestamp: BigInt!
}

interface IpfsMetaData {
  name: String
  image: String
  description: String
  category: Int
  externalUrl: String
  unlockableUrl: String
  explicitContent: Boolean
  tags: [Tag!]
  attributes: [Attribute!]
  files: [File!]
}
